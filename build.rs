use std::env;
use std::fs;
use std::path::Path;

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("generated_tools.rs");

    // Scan the tools directory for #[mcp_tool] annotations
    let tools_dir = Path::new("src/mcp/tools");
    let tools = scan_for_tools(tools_dir);

    // Generate the tool router code
    let generated_code = generate_tool_router_code(&tools);

    fs::write(&dest_path, generated_code).unwrap();

    // Tell cargo to rerun if tools directory changes
    println!("cargo:rerun-if-changed=src/mcp/tools");
}

#[derive(Debug)]
struct ToolInfo {
    name: String,
    description: String,
    args_type: String,
    function_path: String,
}

fn scan_for_tools(dir: &Path) -> Vec<ToolInfo> {
    let mut tools = Vec::new();

    if let Ok(entries) = fs::read_dir(dir) {
        for entry in entries.flatten() {
            let path = entry.path();

            if path.is_dir() {
                // Recursively scan subdirectories
                tools.extend(scan_for_tools(&path));
            } else if path.extension().and_then(|s| s.to_str()) == Some("rs") {
                // Parse Rust files for #[mcp_tool] attributes
                if let Ok(content) = fs::read_to_string(&path) {
                    if let Some(tool) = parse_mcp_tool_from_file(&content, &path) {
                        tools.push(tool);
                    }
                }
            }
        }
    }

    tools
}

fn parse_mcp_tool_from_file(content: &str, file_path: &Path) -> Option<ToolInfo> {
    // Look for #[mcp_tool( pattern
    let mcp_tool_start = content.find("#[mcp_tool(")?;
    let attr_end = content[mcp_tool_start..].find(")]")?;
    let attr_content = &content[mcp_tool_start..mcp_tool_start + attr_end + 2];

    // Extract name and description
    let name = extract_attribute_value(attr_content, "name")?;
    let description = extract_attribute_value(attr_content, "description")?;

    // Find the function signature after the attribute
    let fn_start = content[mcp_tool_start + attr_end..].find("pub async fn ")?;
    let fn_content = &content[mcp_tool_start + attr_end + fn_start..];

    // Extract function name and args type
    let fn_sig_end = fn_content.find('{')?;
    let fn_sig = &fn_content[..fn_sig_end];

    // Extract function name
    let fn_name_start = fn_sig.find("pub async fn ")? + "pub async fn ".len();
    let fn_name_end = fn_sig[fn_name_start..].find('(')?;
    let fn_name = fn_sig[fn_name_start..fn_name_start + fn_name_end].trim();

    // Extract args type (second parameter)
    let args_start = fn_sig.find("args:")? + "args:".len();
    let args_end = fn_sig[args_start..].find(')')?;
    let args_type = fn_sig[args_start..args_start + args_end].trim().to_string();

    // Build function path from file path
    let function_path = build_function_path(file_path, fn_name);

    Some(ToolInfo {
        name,
        description,
        args_type,
        function_path,
    })
}

fn extract_attribute_value(attr: &str, key: &str) -> Option<String> {
    let pattern = format!("{} = \"", key);
    let start = attr.find(&pattern)? + pattern.len();
    let end = attr[start..].find('"')?;
    Some(attr[start..start + end].to_string())
}

fn build_function_path(file_path: &Path, fn_name: &str) -> String {
    // Convert file path to module path
    // e.g., src/mcp/tools/teams/list_teams.rs -> crate::mcp::tools::teams::list_teams
    // But since modules re-export functions, we use the parent module path
    let path_str = file_path.to_str().unwrap();
    let module_path = path_str
        .strip_prefix("src/")
        .unwrap_or(path_str)
        .strip_suffix(".rs")
        .unwrap_or(path_str)
        .replace('/', "::");

    // Get the parent module path (everything before the last ::)
    let parts: Vec<&str> = module_path.rsplitn(2, "::").collect();
    if parts.len() == 2 {
        // Use parent module + function name
        format!("crate::{}::{}", parts[1], fn_name)
    } else {
        // Fallback to full path
        format!("crate::{}::{}", module_path, fn_name)
    }
}

fn generate_tool_router_code(tools: &[ToolInfo]) -> String {
    let mut code = String::from("// Auto-generated by build.rs\n\n");

    // Add necessary imports
    code.push_str("use crate::mcp::tools::classification_nodes::{ListAreaPathsArgs, ListIterationPathsArgs};\n");
    code.push_str(
        "use crate::mcp::tools::organizations::{GetCurrentUserArgs, ListOrganizationsArgs};\n",
    );
    code.push_str("use crate::mcp::tools::projects::ListProjectsArgs;\n");
    code.push_str("use crate::mcp::tools::tags::ListTagsArgs;\n");
    code.push_str("use crate::mcp::tools::teams::{\n");
    code.push_str(
        "    GetTeamArgs, GetTeamCurrentIterationArgs, ListTeamMembersArgs, ListTeamsArgs,\n",
    );
    code.push_str(
        "    boards::{GetBoardArgs, ListBoardColumnsArgs, ListBoardRowsArgs, ListBoardsArgs},\n",
    );
    code.push_str("};\n");
    code.push_str("use crate::mcp::tools::work_item_types::ListWorkItemTypesArgs;\n");
    code.push_str("use crate::mcp::tools::work_items::{\n");
    code.push_str("    AddCommentArgs, CreateWorkItemArgs, GetWorkItemArgs, GetWorkItemsArgs, LinkWorkItemsArgs,\n");
    code.push_str("    QueryWorkItemsArgs, QueryWorkItemsArgsWiql, UpdateWorkItemArgs,\n");
    code.push_str("};\n");
    code.push_str("use rmcp::{\n");
    code.push_str("    ErrorData as McpError,\n");
    code.push_str("    handler::server::wrapper::Parameters,\n");
    code.push_str("    model::CallToolResult,\n");
    code.push_str("    tool, tool_router,\n");
    code.push_str("};\n\n");

    code.push_str("#[tool_router]\nimpl AzureMcpServer {\n");
    code.push_str("    pub fn new(client: AzureDevOpsClient) -> Self {\n");
    code.push_str("        Self {\n");
    code.push_str("            client: Arc::new(client),\n");
    code.push_str("            tool_router: Self::tool_router(),\n");
    code.push_str("        }\n");
    code.push_str("    }\n\n");

    for tool in tools {
        code.push_str(&format!(
            "    #[tool(description = \"{}\")]\n",
            tool.description
        ));
        code.push_str(&format!("    async fn {}(\n", tool.name));
        code.push_str("        &self,\n");
        code.push_str(&format!("        args: Parameters<{}>,\n", tool.args_type));
        code.push_str("    ) -> Result<CallToolResult, McpError> {\n");
        code.push_str(&format!(
            "        {}(&self.client, args.0).await\n",
            tool.function_path
        ));
        code.push_str("    }\n\n");
    }

    code.push_str("}\n");
    code
}
